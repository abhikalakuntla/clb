#!/usr/bin/env python
import cloudlb
import argparse
import os
import os.path
import prettytable
import sys
import textwrap
import httplib2
import time
import ConfigParser
from datetime import datetime, timedelta

# Decorator for args
def arg(*args, **kwargs):
    def _decorator(func):
        # Because of the sematics of decorator composition if we just append
        # to the options list positional options will appear to be backwards.
        func.__dict__.setdefault('arguments', []).insert(0, (args, kwargs))
        return func
    return _decorator

class CommandError(Exception):
    pass

def env(e):
    return os.environ.get(e, '')

class CloudloadbalancersShell(object):

    # Hook for the test suite to inject a fake load balancer.
    _api_class = cloudlb.CloudLoadBalancer

    def __init__(self):
        self.parser = argparse.ArgumentParser(
            prog = 'clb',
            #description = __doc__.strip(),
            epilog = 'See "clb help COMMAND" for help on a specific command.',
            add_help = False,
            formatter_class = CloudloadbalancersHelpFormatter,
        )

        # Global arguments
        self.parser.add_argument('-h', '--help',
            action = 'help',
            help = argparse.SUPPRESS)

        self.parser.add_argument('--debug',
            default = False,
            action = 'store_true',
            help = argparse.SUPPRESS)

        self.parser.add_argument('--username',
            default = env('CLOUD_LOADBALANCERS_USERNAME') or env('CLOUD_SERVERS_USERNAME'),
            help = 'Defaults to env[CLOUD_LOADBALANCERS_USERNAME] or env[CLOUD_SERVERS_USERNAME].')
            
        self.parser.add_argument('--apikey',
            default = env('CLOUD_LOADBALANCERS_API_KEY') or env('CLOUD_SERVERS_API_KEY'),
            help='Defaults to env[CLOUD_LOADBALANCERS_API_KEY] env[CLOUD_SERVERS_API_KEY].')

        self.parser.add_argument('--region',
            default = env('CLOUD_LOADBALANCERS_REGION'),
            help='Defaults to env[CLOUD_LOADBALANCERS_REGION].')

        # Subcommands
        subparsers = self.parser.add_subparsers(metavar='<subcommand>')
        self.subcommands = {}

        # Everything that's do_* is a subcommand.
        for attr in (a for a in dir(self) if a.startswith('do_')):
            # I prefer to be hypen-separated instead of underscores.
            command = attr[3:].replace('_', '-')
            callback = getattr(self, attr)
            desc = callback.__doc__ or ''
            help = desc.strip().split('\n')[0]
            arguments = getattr(callback, 'arguments', [])
            
            subparser = subparsers.add_parser(command,
                help = help,
                description = desc,
                add_help=False,
                formatter_class = CloudloadbalancersHelpFormatter
            )
            subparser.add_argument('-h', '--help',
                action = 'help',
                help = argparse.SUPPRESS,
            )
            self.subcommands[command] = subparser
            for (args, kwargs) in arguments:
                subparser.add_argument(*args, **kwargs)
            subparser.set_defaults(func=callback)

    def main(self, argv):
        # Parse args and call whatever callback was selected
        args = self.parser.parse_args(argv)

        # Short-circuit and deal with help right away.
        if args.func == self.do_help:
            self.do_help(args)
            return 0
                
        # Deal with global arguments
        if args.debug:
            httplib2.debuglevel = 1
     
        user, apikey, region  = args.username, args.apikey, args.region
 
        if not user:
            raise CommandError("You must provide a username, either via "
                               "--username or via env[CLOUD_SERVERS_USERNAME]")
        if not apikey:
            raise CommandError("You must provide an API key, either via "
                               "--apikey or via env[CLOUD_SERVERS_API_KEY]")

        if not region:
            raise CommandError("You must provide a region location, either via "
                               "--region or via env[CLOUD_LOADBALANCERS_REGION]")

        self.clb = self._api_class(user, apikey, region)

        # If we have a recent authtoken, try to use it.
        reused_authkey = False
        configreader = ConfigParser.RawConfigParser()
        configfilename = os.path.expanduser('~/.clb-lastconnection')
        if os.path.exists(configfilename):
            configreader.read(configfilename)
            ts = configreader.get('connection', 'timestamp')
            then = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S")
            now = datetime.now()
            duration = now - then
            if duration.days < 1:
                reused_authkey = True
                self.clb.client.auth_token = configreader.get('connection', 'authtoken')
                self.clb.client.region_account_url = configreader.get('connection', 'regionurl')

        try:
            args.func(args)
        except cloudlb.errors.ResponseError as e:
            if e.status == 401 and e.reason == 'Unauthorized' and reused_authkey:
                # If the old auth token didn't work, try again as if it wasn't read
                self.clb.client.auth_token = None
                self.clb.client.region_account_url = None
                args.func(args)
            else:
                print >> sys.stderr, "ERROR: API error %d. %s" % (e.status, e.reason) 

        with open(configfilename, 'wb') as configfile:
            configwriter = ConfigParser.RawConfigParser()
            configwriter.add_section('connection')
            configwriter.set('connection', 'authtoken', self.clb.client.auth_token)
            configwriter.set('connection', 'regionurl', self.clb.client.region_account_url)
            configwriter.set('connection', 'timestamp', datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
            configwriter.write(configfile)
            os.chmod(configfilename, 0600)

    def findlb(self, lbstr, readonly=True):
        """Find a load balacer by name or id.  Optionally, delay until the load balancer can be modified."""
        lb = self._lb_name_or_id(lbstr)
        if not readonly:
            lb = self._wait_for_modification(lb)
        return lb

    def _lb_name_or_id(self, lbstr):
        """Determine if lbstr is a load balancer name or id"""
        try:
            lb = self.clb.loadbalancers.get(int(lbstr))
        except ValueError:
            lb = self.clb.loadbalancers.find(name=lbstr)
        return lb 

    def _wait_for_modification(self, lb, wait=2, timeout=30):
        """Wait until the load balancer is in a state that will allow it to be modified."""
        count = 0
        while lb.status != 'ACTIVE':
            if count >= timeout:
                break
            count += wait
            time.sleep(wait)
            lb = self._lb_name_or_id(lb.id)  
        return lb

    @arg('command', metavar='<subcommand>', nargs='?', help='Display help for <subcommand>')
    def do_help(self, args):
        """
        Display help about this program or one of its subcommands.
        """
        if args.command:
            if args.command in self.subcommands:
                self.subcommands[args.command].print_help()
            else:
                raise CommandError("'%s' is not a valid subcommand." % args.command)
        else:
            self.parser.print_help()

    # Load balancer operations
    @arg('name', metavar='<name>', help='Name of load balancer.')
    @arg('port', metavar='<port>', help='Load balancer port number.')
    @arg('protocol', metavar='<protocol>', help='Load balancer protocol type.')
    @arg('nodes', metavar='<nodes>', help='Comma separated list of nodes.  Ex. "10.1.1.1:80,10.2.2.2:80".')
    @arg('vip', metavar='<vip>', help='Virtual IP.  Either "public", "servicenet", or ID of existing VIP to share.')
    def do_create(self, args):
        """Create new load balancer."""
        nodes = split_nodes(args.nodes) 

        if not args.vip in ["public", "servicenet"]:
            vip = cloudlb.VirtualIP(id=int(args.vip))
        else:
            vip = cloudlb.VirtualIP(type=args.vip.upper())

        lb = self.clb.loadbalancers.create(name=args.name, port=args.port, 
          protocol=args.protocol,nodes=nodes, virtualIps=[vip])

        args.loadbalancer = lb.id
        self.do_show(args)

    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    def do_delete(self, args):
        """Delete a load balancer"""
        lb = self.findlb(args.loadbalancer) 
        lb.delete()

    def do_list(self, args):
        """List active load balancers."""
        fields = ['Name', 'ID', 'Port', 'Protocol', 'Algorithm', 'Nodes', 'IPs']
        rows = []
        lbs = self.clb.loadbalancers.list()
        for lb in lbs:
            ips = []
            for ip in lb.virtualIps:
                ips.append("%s/%s" % (ip.ipVersion, ip.address))
            rows.append([lb.name, lb.id, lb.port, lb.protocol, lb.algorithm, len(lb.nodes), csv_list(ips)])
        print_list2(fields, rows)

    def do_list_deleted(self, args):
        """List deleted load balancers."""
        fields = ['Name', 'ID']
        rows = []
        lbs = self.clb.loadbalancers.list_deleted()
        for lb in lbs:
            rows.append([lb.name, lb.id])
        print_list2(fields, rows)

    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    def do_show(self, args):
        """List details of a specific load balancer."""
        lb = self.findlb(args.loadbalancer) 
        fields = ['Field', 'Value']
        rows = []
        rows.append(['Name', lb.name])
        rows.append(['ID', lb.id])
        rows.append(['Status', lb.status])
        rows.append(['Port', lb.port])
        rows.append(['Protocol', lb.protocol])
        rows.append(['Algorithm', lb.algorithm])
        for i in range(len(lb.virtualIps)):
            ip = lb.virtualIps[i]
            vstr = '%s (%s)' % (ip.address, ip.type)
            rows.append(['VIP ' + str(ip.id), vstr])
        for i in range(len(lb.nodes)):
            node = lb.nodes[i]
            if node.weight is not None:
                nstr = '%s:%s (Weight %d) / %s / %s' % (node.address, node.port, node.weight, node.condition, node.status)
            else:
                nstr = '%s:%s / %s / %s' % (node.address, node.port, node.condition, node.status)
            rows.append(['Node ' + str(i + 1), nstr])
        sp = lb.session_persistence()
        sptype = sp.get()
        if sptype is not None:
            sptype = sptype.persistenceType
        rows.append(['Session Persistence', sptype])
        rows.append(['Connection Logging', lb.connection_logging().get()])
        rows.append(['Cluster', lb.cluster])
        rows.append(['Created', lb.created])
        rows.append(['Updated', lb.updated])
 
        print_list2(fields, rows)
        # TODO
        # - ACL

    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    def do_show_usage(self, args):
        """Display load balancer usage.""" 
        lb = self.findlb(args.loadbalancer) 
        for u in lb.get_usage():
            print_dict(u)

    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    @arg('name', metavar='<name>', help="New load balancer name.")
    def do_rename(self,args):
        """Rename an existing load balancer."""
        lb = self.findlb(args.loadbalancer)
        lb.name = args.name
        lb.update()

    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    @arg('protocol', metavar='<protocol>', help="New protocol.")
    def do_change_protocol(self,args):
        """Change the protocol of an existing load balancer."""
        lb = self.findlb(args.loadbalancer, readonly=False) 
        lb.protocol = args.protocol
        lb.update()

    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    @arg('algorithm', metavar='<algorithm>', help="Full algorithm name or shorthand (rr, lc, rand, wlc, wrr)")
    def do_change_algorithm(self,args):
        """Change the algorithm of an existing load balancer."""
        lb = self.findlb(args.loadbalancer) 
        lb.algorithm = algorithm_shorthand(args.algorithm)
        lb.update()

    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    @arg('port', metavar='<port>', help="Port number.")
    def do_change_port(self,args):
        """Change the port number of an existing load balancer."""
        lb = self.findlb(args.loadbalancer) 
        lb.port = int(args.port)
        lb.update()

    # Node operations
    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    @arg('nodes', metavar='<nodes>', help='Comma separated list of nodes.  Ex. "10.1.1.1:80,10.2.2.2:80".')
    def do_add_nodes(self, args):
        """Add nodes to an existing load balancer."""
        lb = self.findlb(args.loadbalancer) 
        nodes = split_nodes(args.nodes)
        lb.add_nodes(nodes)

    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    @arg('nodes', metavar='<nodes>', help='Comma separated list of nodes.  Ex. "10.1.1.1:80,10.2.2.2:80".')
    def do_remove_nodes(self, args):
        """Remove nodes from an existing load balancer."""
        node_strings = args.nodes.split(',')
        lb = self.findlb(args.loadbalancer, readonly=False) 
        for ns in node_strings:
            lb = self._remove_nodes(lb, ns)

    def _remove_nodes(self, lb, nodestr):
        """Find and delete a node given the string 'IP:port'. Returns a load balancer that can be further modified."""
        for n in lb.nodes:
            destination = "%s:%d" % (n.address, n.port)
            if destination == nodestr:
                n.delete()
                return self.findlb(lb.id, readonly=False)

    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    @arg('nodes', metavar='<nodes>', help='Comma separated list of nodes.  Ex. "10.1.1.1:80,10.2.2.2:80".')
    @arg('weight', metavar='<weight>', help='Weight integer value.')
    def do_change_nodes_weight(self, args):
        """Set weight for existing nodes."""
        node_strings = args.nodes.split(',')
        lb = self.findlb(args.loadbalancer) 
        for n in lb.nodes:
            destination = "%s:%d" % (n.address, n.port)
            if destination in node_strings:
                n.weight = args.weight
                n.update()

    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    @arg('nodes', metavar='<nodes>', help='Comma separated list of nodes.  Ex. "10.1.1.1:80,10.2.2.2:80".')
    def do_enable_nodes(self, args):
        """Enable existing nodes."""
        node_strings = args.nodes.split(',')
        lb = self.findlb(args.loadbalancer) 
        for n in lb.nodes:
            destination = "%s:%d" % (n.address, n.port)
            if destination in node_strings:
                n.condition = 'ENABLED'
                n.update()

    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    @arg('nodes', metavar='<nodes>', help='Comma separated list of nodes.  Ex. "10.1.1.1:80,10.2.2.2:80".')
    def do_disable_nodes(self, args):
        """Disable existing nodes."""
        node_strings = args.nodes.split(',')
        lb = self.findlb(args.loadbalancer) 
        for n in lb.nodes:
            destination = "%s:%d" % (n.address, n.port)
            if destination in node_strings:
                n.condition = 'DISABLED'
                n.update()

    # Monitor operations
    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    def do_show_monitor(self, args):
        """Display load balancer's monitor."""
        lb = self.findlb(args.loadbalancer) 
        monitor = lb.healthmonitor()
        m = monitor.get()
        if m == None:
            print "No monitor configured."
        else:
            fields = ['Field', 'Value']
            rows = []
            rows.append(['Type', m.type])
            rows.append(['Delay', m.delay])
            rows.append(['Timeout', m.timeout])
            rows.append(['Attempts', m.attemptsBeforeDeactivation])

            if m.type in ['HTTP', 'HTTPS']:
                rows.append(['Path', m.path])
                rows.append(['Status Regex', m.statusRegex])
                rows.append(['Body Regex', m.bodyRegex])

            print_list2(fields, rows)

    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    @arg('delay', metavar='<delay>', help='The minimum number of seconds to wait before executing the health monitor.')
    @arg('timeout', metavar='<timeout>', help='Maximum number of seconds to wait for a connection to be established before timing out.')
    @arg('attempts', metavar='<attempts>', help='Number of permissible monitor failures before removing a node from rotation.')
    def do_set_monitor_connect(self,args):
        """Set the monitor to TCP connect for an existing load balancer."""
        lb = self.findlb(args.loadbalancer) 
        monitor = lb.healthmonitor()
        hm = cloudlb.healthmonitor.HealthMonitor(
          type="CONNECT",
          delay=int(args.delay),
          timeout=int(args.timeout),
          attemptsBeforeDeactivation=int(args.attempts))
        monitor.add(hm)

    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    @arg('delay', metavar='<delay>', help='The minimum number of seconds to wait before executing the health monitor.')
    @arg('timeout', metavar='<timeout>', help='Maximum number of seconds to wait for a connection to be established before timing out.')
    @arg('attempts', metavar='<attempts>', help='Number of permissible monitor failures before removing a node from rotation.')
    @arg('path', metavar='<path>', help='The HTTP path that will be used in the monitor request.')
    @arg('status', metavar='<status>', help='A regular expression that will be used to evaluate the HTTP status code returned in the response.')
    @arg('body', metavar='<body>', help='')
    def do_set_monitor_http(self, args):
        """Set the monitor to HTTP for an existing load balancer."""
        lb = self.findlb(args.loadbalancer) 
        monitor = lb.healthmonitor()
       
        if args.status == 'standard':
            args.status = '^[234][0-9][0-9]$'

        hm = cloudlb.healthmonitor.HealthMonitor(
          type="HTTP",
          delay=int(args.delay),
          timeout=int(args.timeout),
          attemptsBeforeDeactivation=int(args.attempts),
          path=args.path,
          statusRegex=args.status,
          bodyRegex=args.body)
        monitor.add(hm)
        
    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    @arg('delay', metavar='<delay>', help='The minimum number of seconds to wait before executing the health monitor.')
    @arg('timeout', metavar='<timeout>', help='Maximum number of seconds to wait for a connection to be established before timing out.')
    @arg('attempts', metavar='<attempts>', help='Number of permissible monitor failures before removing a node from rotation.')
    @arg('path', metavar='<path>', help='The HTTP patch that will be used in the monitor request.')
    @arg('status', metavar='<status>', help='A regular expression that will be used to evaluate the HTTP status code returned in the response.')
    @arg('body', metavar='<body>', help='')
    def do_set_monitor_https(self, args):
        """Set the monitor to HTTPS for an existing load balancer."""
        lb = self.findlb(args.loadbalancer) 
        monitor = lb.healthmonitor()
        hm = cloudlb.healthmonitor.HealthMonitor(
          type="HTTPS",
          delay=int(args.delay),
          timeout=int(args.timeout),
          attemptsBeforeDeactivation=int(args.attempts),
          path=args.path,
          statusRegex=args.status,
          bodyRegex=args.body)
        monitor.add(hm)

    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    def do_delete_monitor(self, args):
        """Delete the health monitor."""
        lb = self.findlb(args.loadbalancer, readonly=False) 
        monitor = lb.healthmonitor()
        monitor.delete()

    # Connection logging
    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    def do_enable_logging(self, args):
        """Enable connection logging."""
        lb = self.findlb(args.loadbalancer, readonly=False) 
        cl = lb.connection_logging()
        cl.enable()

    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    def do_disable_logging(self, args):
        """Disable connection logging."""
        lb = self.findlb(args.loadbalancer, readonly=False) 
        cl = lb.connection_logging()
        cl.disable()

    # Persistence
    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    def do_enable_persistence(self, args):
        """Enable HTTP cookie session persistence"""
        lb = self.findlb(args.loadbalancer, readonly=False) 
        ss = cloudlb.sessionpersistence.SessionPersistence(persistenceType="HTTP_COOKIE")
        ssp = lb.session_persistence()
        ssp.add(ss)

    @arg('loadbalancer', metavar='<loadbalancer>', help='Name or ID of load balancer.')
    def do_disable_persistence(self, args):
        """Disable HTTP cookie session persistence"""
        lb = self.findlb(args.loadbalancer, readonly=False) 
        ssp = lb.session_persistence()
        ssp.delete()

    # Load balancer features
    def do_list_algorithms(self, args):
        """List the available load balancing algorithms."""
        print_list2(['Algorithms'], self.clb.get_algorithms())

    def do_list_protocols(self, args):
        """List the available protocols."""
        print_list2(['Protocols'], self.clb.get_protocols()) 

class CloudloadbalancersHelpFormatter(argparse.HelpFormatter):
    def start_section(self, heading):
        # Title-case the headings
        heading = '%s%s' % (heading[0].upper(), heading[1:])
        super(CloudloadbalancersHelpFormatter, self).start_section(heading)

# Helper functions
def algorithm_shorthand(algorithm):
    """Convert abbreviated algorithm names to the full version."""
    shorthand = {'rr': 'ROUND_ROBIN', 
      'rand': 'RANDOM', 
      'lc': 'LEAST_CONNECTIONS',
      'wlc': 'WEIGHTED_LEAST_CONNECTIONS',
      'wrr': 'WEIGHTED_ROUND_ROBIN'}
    if algorithm in shorthand:
        return shorthand[algorithm]
    else:
        return algorithm.upper()

def split_nodes(node_string):
    """Split CSV string in IP:Port format into a list of Cloudlb.Nodes """
    nodes = []
    for server in node_string.split(','):
        (ip, port) = server.split(':')
        node = cloudlb.Node(address=ip, port=port, condition='ENABLED')
        nodes.append(node)
    return nodes

def csv_list(listtext, sep1=', ', sep2=', and '):
        return (len(listtext) > 1 
        and ("%s%s%s" % (sep1.join(listtext[:-1]), sep2, listtext[-1])) 
        or listtext[0])

def print_list2(fields, rows):
    if len(rows) > 0:
        pt = prettytable.PrettyTable(fields)
        pt.aligns = ['l' for f in fields]
        for r in rows:
            if isinstance(r, list):
                pt.add_row(r)
            else:
                pt.add_row([r])
        pt.printt()

def print_list(objs, fields, formatters={}):
    pt = prettytable.PrettyTable([f for f in fields], caching=False)
    pt.aligns = ['l' for f in fields]
    
    for o in objs:
        row = []
        for field in fields:
            if field in formatters:
                row.append(formatters[field](o))
            else:
                row.append(getattr(o, field.lower().replace(' ', '_'), ''))
        pt.add_row(row)
    
    pt.printt(sortby=fields[0])
    
def print_dict(d):
    pt = prettytable.PrettyTable(['Property', 'Value'], caching=False)
    pt.aligns = ['l', 'l']
    [pt.add_row(list(r)) for r in d.iteritems()]
    pt.printt(sortby='Property')

if __name__ == "__main__":
    try:
        CloudloadbalancersShell().main(sys.argv[1:])
    except CommandError, e:
        print >> sys.stderr, e
        sys.exit(1)
